# loki

<!-- BEGINNING OF PRE-COMMIT-TERRAFORM DOCS HOOK -->
## Requirements

| Name | Version |
|------|---------|
| <a name="requirement_terraform"></a> [terraform](#requirement\_terraform) | >= 1.3.0 |
| <a name="requirement_helm"></a> [helm](#requirement\_helm) | >= 2.0 |
| <a name="requirement_kubernetes"></a> [kubernetes](#requirement\_kubernetes) | >2.3 |
| <a name="requirement_random"></a> [random](#requirement\_random) | > 3.7 |

## Providers

| Name | Version |
|------|---------|
| <a name="provider_helm"></a> [helm](#provider\_helm) | >= 2.0 |
| <a name="provider_random"></a> [random](#provider\_random) | > 3.7 |

## Modules

No modules.

## Resources

| Name | Type |
|------|------|
| [helm_release.loki](https://registry.terraform.io/providers/hashicorp/helm/latest/docs/resources/release) | resource |
| [helm_release.promtail](https://registry.terraform.io/providers/hashicorp/helm/latest/docs/resources/release) | resource |
| [random_string.random](https://registry.terraform.io/providers/hashicorp/random/latest/docs/resources/string) | resource |

## Inputs

| Name | Description | Type | Default | Required |
|------|-------------|------|---------|:--------:|
| <a name="input_configs"></a> [configs](#input\_configs) | Values to pass to loki helm chart | <pre>object({<br/>    loki = optional(object({<br/>      chart_version    = optional(string, "6.34.0")       # the loki chart version, NOTE: the helm versions >=6.35.0 bring loki-0 pod crash-loops with default configs, makes ure you test things before helm upgrade to newer versions<br/>      release_name     = optional(string, "loki")         # the loki chart release name<br/>      deploymentMode   = optional(string, "SingleBinary") # we have SingleBinary mode by default, and in this mode distributor, ingester, querier, ... and several other components are within single binary loki app<br/>      replicas         = optional(number, 1)              # number of main loki replicas in SingleBinary mode, in SingleBinary mode it is recommended to have replica count always 1<br/>      auth_enabled     = optional(bool, false)            # should authentication be enabled<br/>      structuredConfig = optional(any, {})                # this provide structured way to pass the loki all configs that available in https://grafana.com/docs/loki/latest/configure/ , for additional field support here code change may be needed or one can use extra_configs option<br/>      commonConfig = optional(object({                    # for more info check https://grafana.com/docs/loki/latest/configuration/#common_config<br/>        replication_factor = optional(number, 1)          # the number of ingesters to write to and read from.<br/>      }), {})<br/>      resources = optional(object({ # resources of loki in SingleBinary mode<br/>        requests = optional(object({<br/>          cpu    = optional(string, "100m")<br/>          memory = optional(string, "100Mi")<br/>        }), {})<br/>        limits = optional(object({<br/>          cpu    = optional(string, "1500m")<br/>          memory = optional(string, "2000Mi")<br/>        }), {})<br/>      }), {})<br/>      serviceAccount = optional(object({ # the service account configs that will be assigned to loki main component<br/>        enable      = optional(bool, true)<br/>        name        = optional(string, "loki")<br/>        annotations = optional(map(string), {})<br/>      }), {})<br/>      monitoring = optional(object({ # monitoring related configs<br/>        serviceMonitor = optional(object({<br/>          enabled = optional(bool, true) # whether service monitor is enabled<br/>        }), {})<br/>      }), {})<br/>      ingress = optional(object({ # allows to have loki service accessible from external<br/>        enabled = optional(bool, false)<br/>        type    = optional(string, "nginx")<br/>        public  = optional(bool, true)<br/>        tls = optional(object({<br/>          enabled       = optional(bool, true)<br/>          cert_provider = optional(string, "letsencrypt-prod")<br/>        }), {})<br/>        annotations = optional(map(string), {})<br/>        hosts       = optional(list(string), ["loki.example.com"])<br/>        path        = optional(string, "/")<br/>        path_type   = optional(string, "Prefix")<br/>      }), {})<br/>      schemaConfig = optional(list(object({           # Configures the chunk index schema and where it is stored. for more info check https://grafana.com/docs/loki/latest/configure/#schema_config<br/>        from         = optional(string, "2025-01-01") # defines starting at which date this storage schema will be applied        from         = optional(string, "2025-01-01")<br/>        object_store = optional(string, "filesystem")<br/>        store        = optional(string, "tsdb")<br/>        schema       = optional(string, "v13")<br/>        index = optional(object({<br/>          prefix = optional(string, "index_")<br/>          period = optional(string, "24h")<br/>        }), {})<br/>      })), [{}])<br/>      limits_config = optional(object({                                   # this allows setting limitations and enabling some features for loki. https://grafana.com/docs/loki/latest/configure/#limits_config<br/>        max_query_length          = optional(string, "7d1h")              # the limit to length of chunk store queries. 0 to disable.<br/>        retention_period          = optional(string, "360h")              # retention period to apply to stored data, only applies if retention_enabled=true in the compactor config. Must be either 0(disabled) or a multiple of 24h, 360h=15days<br/>        deletion_mode             = optional(string, "filter-and-delete") # the Deletion mode, Can be one of 'disabled','filter-only', "filter-and-delete". When set to 'filter-only' or 'filter-and-delete', and if retention_enabled=true in the compactor config, then the log entry deletion API endpoints are available<br/>        volume_enabled            = optional(bool, true)                  # enables Loki log-volume index queries what can be used in grafana visualize log volume (LogQL â†’ bytes_over_time)<br/>        allow_structured_metadata = optional(bool, true)                  # allow user to send structured metadata in push payload.<br/>        discover_log_levels       = optional(bool, true)                  # discover and add log levels(detected_level) during ingestion, if not present already.<br/>      }), {})<br/>      compactor_options = optional(object({ # compactor component options, for retention the compactor must run/configured, in "SingleBinary" mode compactor runs in loki single binary and there is no need for compactor separate component so we need only<br/>        retention_enabled    = optional(bool, true)<br/>        working_directory    = optional(string, "/var/loki/compactor")<br/>        delete_request_store = optional(string, "filesystem")<br/>      }), {})<br/>      persistence = optional(object({ # enable persistent disk and configure<br/>        enabled      = optional(bool, true)<br/>        size         = optional(string, "20Gi")<br/>        storageClass = optional(string, "")<br/>        selector     = optional(string, null)<br/>        annotations  = optional(any, {})<br/>      }), {})<br/>      storage = optional(any, { # the storage where loki will place its data, Loki requires a bucket for chunks and the ruler<br/>        type = "filesystem",<br/>        filesystem = {<br/>          chunks_directory    = "/var/loki/chunks"<br/>          rules_directory     = "/var/loki/rules"<br/>          admin_api_directory = "/var/loki/admin"<br/>        }<br/>        bucketNames = {<br/>          chunks = "unused-for-filesystem"<br/>          ruler  = "unused-for-filesystem"<br/>          admin  = "unused-for-filesystem"<br/>        }<br/>      })<br/><br/>      # loki stack other components configs(in SingleBinary mode most of them as separate component are disabled)<br/>      chunksCache = optional(object({            # memcached based cache service which being used for chunks caching and improves loki performance when querying data<br/>        enabled         = optional(bool, true)   # whether enabled, we have this enabled by default, but can be disabled manually<br/>        allocatedMemory = optional(number, 8192) # the memory in MBs we attach to this component, the pods requested memory being calculated based on expression round(allocatedMemory * 1.2)<br/>      }), {})<br/>      resultsCache = optional(object({           # memcached based cache service which being used for chunks caching and improves loki performance when querying data<br/>        enabled         = optional(bool, true)   # whether enabled, we have this enabled by default, but can be disabled manually<br/>        allocatedMemory = optional(number, 1024) # the memory in MBs we attach to this component, the pods requested memory being calculated based on expression round(allocatedMemory * 1.2)<br/>      }), {})<br/>      test           = optional(any, { enabled = false })               # helm tests configs<br/>      lokiCanary     = optional(any, { enabled = false })               # the Loki canary pushes logs to and queries from this loki installation to test that it's working correctly<br/>      ruler          = optional(any, { enabled = false, replicas = 0 }) # the internal loki alerting module, which we do not need as we are going to use grafana alerting mechanism<br/>      compactor      = optional(any, { replicas = 0 })                  # compactor component, in SingleBinary mode this included in loki<br/>      read           = optional(any, { replicas = 0 })                  # read component, in SingleBinary mode this included in loki<br/>      write          = optional(any, { replicas = 0 })                  # write component, in SingleBinary mode this included in loki<br/>      backend        = optional(any, { replicas = 0 })                  # backend component, in SingleBinary mode this included in loki<br/>      ingester       = optional(any, { replicas = 0 })                  # ingester component, in SingleBinary mode this included in loki<br/>      querier        = optional(any, { replicas = 0 })                  # querier component, in SingleBinary mode this included in loki<br/>      queryFrontend  = optional(any, { replicas = 0 })                  # queryFrontend component, in SingleBinary mode this included in loki<br/>      queryScheduler = optional(any, { replicas = 0 })                  # queryScheduler component, in SingleBinary mode this included in loki<br/>      distributor    = optional(any, { replicas = 0 })                  # distributor component, in SingleBinary mode this included in loki<br/>      indexGateway   = optional(any, { replicas = 0 })                  # indexGateway component, in SingleBinary mode this included in loki<br/>      bloomBuilder   = optional(any, { replicas = 0 })                  # bloomBuilder component, in SingleBinary mode this included in loki<br/>      bloomPlanner   = optional(any, { replicas = 0 })                  # bloomPlanner component, in SingleBinary mode this included in loki<br/>      bloomGateway   = optional(any, { replicas = 0 })                  # bloomGateway component, in SingleBinary mode this included in loki<br/><br/>      extra_configs = optional(any, {}) # allows to pass extra/custom configs to loki helm chart, this configs will deep-merged with all generated internal configs and can override the default set ones. All available options can be found in for the specified chart version here: https://artifacthub.io/packages/helm/grafana/loki?modal=values<br/>    }), {})<br/>    # TODO: the promtail deprecated, consider to have this replaced with for example fluent/fluent-bit<br/>    promtail = optional(object({ # promtail configs, which is the default tool we have to collect and push logs to loki<br/>      enabled               = optional(bool, true)<br/>      chart_version         = optional(string, "6.17.1") # the promtail chart version<br/>      log_level             = optional(string, "info")<br/>      server_port           = optional(string, "3101")<br/>      clients               = optional(list(string), [])<br/>      log_format            = optional(string, "logfmt")<br/>      extra_scrape_configs  = optional(list(any), [])<br/>      extra_label_configs   = optional(list(map(string)), [])<br/>      extra_pipeline_stages = optional(any, [])<br/>      ignored_containers    = optional(list(string), [])<br/>      ignored_namespaces    = optional(list(string), [])<br/>      extra_configs         = optional(any, {}) # allows to pass extra/custom configs to promtail helm chart, this configs will deep-merged with all generated internal configs and can override the default set ones. All available options can be found in for the specified chart version here: https://artifacthub.io/packages/helm/grafana/promtail?modal=values<br/>    }), {})<br/>  })</pre> | `{}` | no |
| <a name="input_create_namespace"></a> [create\_namespace](#input\_create\_namespace) | Whether create namespace if not exist | `bool` | `true` | no |
| <a name="input_namespace"></a> [namespace](#input\_namespace) | namespace for deployment of chart | `string` | `"monitoring"` | no |
| <a name="input_promtail_chart_version"></a> [promtail\_chart\_version](#input\_promtail\_chart\_version) | promtail chart version | `string` | `"6.17.0"` | no |

## Outputs

| Name | Description |
|------|-------------|
| <a name="output_helm_metadata_loki"></a> [helm\_metadata\_loki](#output\_helm\_metadata\_loki) | loki helm release metadata |
| <a name="output_helm_metadata_promtail"></a> [helm\_metadata\_promtail](#output\_helm\_metadata\_promtail) | promtail helm release metadata |
<!-- END OF PRE-COMMIT-TERRAFORM DOCS HOOK -->
